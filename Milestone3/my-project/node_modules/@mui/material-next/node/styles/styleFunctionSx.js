"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sx = exports.default = exports.color = exports.borderRadius = exports.bgcolor = exports.backgroundColor = void 0;
var _system = require("@mui/system");
function paletteStyle(options = {
  prop: 'color'
}) {
  const {
    prop,
    cssProperty = options.prop
  } = options;
  const fn = props => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const colorThemeMapping = (0, _system.getPath)(theme, 'sys.color') || {};
    const paletteThemeMapping = (0, _system.getPath)(theme, 'ref.palette') || {};
    const styleFromPropValue = propValueFinal => {
      // check the value in the color mapping first
      let value = (0, _system.getStyleValue)(colorThemeMapping, undefined, propValueFinal);
      if (propValueFinal === value) {
        // haven't found value in colors mapping, so we are checking in the palette mapping
        value = (0, _system.getStyleValue)(paletteThemeMapping, undefined, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return (0, _system.handleBreakpoints)(props, propValue, styleFromPropValue);
  };
  fn.propTypes = process.env.NODE_ENV !== 'production' ? {
    [prop]: _system.responsivePropType
  } : {};
  fn.filterProps = [prop];
  return fn;
}

// Palette values should reference the color tokens
const color = paletteStyle({
  prop: 'color'
});
exports.color = color;
const bgcolor = paletteStyle({
  prop: 'bgcolor',
  cssProperty: 'backgroundColor'
});
exports.bgcolor = bgcolor;
const backgroundColor = paletteStyle({
  prop: 'backgroundColor'
});
exports.backgroundColor = backgroundColor;
const palette = (0, _system.compose)(color, bgcolor, backgroundColor);

// Border radius should mapa to md3.shape
const borderRadius = props => {
  if (props.borderRadius !== undefined && props.borderRadius !== null) {
    const transformer = (0, _system.createUnaryUnit)(props.theme, 'md3.shape.borderRadius', 4, 'borderRadius');
    const styleFromPropValue = propValue => ({
      // @ts-ignore
      borderRadius: (0, _system.getStyleValue)(transformer, propValue)
    });
    return (0, _system.handleBreakpoints)(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
exports.borderRadius = borderRadius;
borderRadius.propTypes = process.env.NODE_ENV !== 'production' ? {
  borderRadius: _system.responsivePropType
} : {};
const borderColor = paletteStyle({
  prop: 'borderColor'
});
borderRadius.filterProps = ['borderRadius'];
const borders = (0, _system.compose)(_system.border, _system.borderTop, _system.borderRight, _system.borderBottom, _system.borderLeft, borderColor, _system.borderTopColor, _system.borderRightColor, _system.borderBottomColor, _system.borderLeftColor, borderRadius);
const styleFunctionMapping = {
  borders,
  display: _system.display,
  flexbox: _system.flexbox,
  grid: _system.grid,
  positions: _system.positions,
  palette,
  sizing: _system.sizing,
  spacing: _system.spacing,
  typography: _system.typography
};
const styleFunctionSx = (0, _system.unstable_createStyleFunctionSx)(styleFunctionMapping);
styleFunctionSx.filterProps = ['sx'];
const sx = styles => {
  return ({
    theme
  }) => styleFunctionSx({
    sx: styles,
    theme
  });
};
exports.sx = sx;
var _default = styleFunctionSx;
exports.default = _default;